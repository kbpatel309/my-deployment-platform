=== DAY 1 START ===

What I just did: Cloned a GitHub repo (my ListAI project) using git clone
Why: I need the code on my computer to build it
What I learned: git clone [paste-the-url-you-copied] [name-of-folder-you-want-to-have-cloned-repo]
Problems I hit: None

What I just did: Ran npm install
Why: Downloads all the libraries/packages the project needs
What I learned: "npm install" command downloads and installs packages (also known as modules or libraries) and their dependencies,
making them available for use within a project. Some things npm install does is:
    * Reads package.json: When executed in a directory that has package.json file, npm install reads the file to identify the
      project's declared dependencies, which are listed under dependencies and devDependecies.
    * Consults package-lock.json: If this file exists, the command uses it to ensure the exact versions of the packages previously
      installed are re-installed, promoting consistency across different environments.
    * Downloads packages: It fetches the required packages and their respective dependencies from npm registry.
    * Creates node_modules folder: The downloaded packages are placed in this folder within the project directory. The folder has
      all the necessary code for the project's dependencies.
    * Handles dependencies recursively: If a package itself has dependencies, npm install recursively downloads and installs those.
Problems I hit: None

What I just did: Ran npm run build
Why: Converts the source code into files a browser can understand
Problem: Build failed because the app needs a Convex url
What I learned: Some apps need environment variables (API keys, URLs) to build
Real insight: Deployment platforms like Vercel handle this with environment variable settings

=== DAY 1 COMPLETED ===

What I accomplished:
- Cloned a repo (first one had external dependencies, learned about environment variables)
- Created a fresh Next.js app using create-next-app
- Successfully ran npm install
- Successfully ran npm run build
- Served it locally and viewed it in browser

What was hardest:
- Hardest thing was the Convex error. All I saw was that there was an error related to Convex (my ListAI project) and had to use a new app

What I still don't understand:
- How to read the error related to Convex

=== DAY 2 START ===

Pomodoro 1 done - creating file and test python.
What I did: Created deploy.py function and made a function that accepts a URLs
What I learned: Learned f-string (or formatted string literal) is Python way to embed expressions in string literal
Problems: None

Pomodoro 2 done - make it clone repo.
What I did: Made the Python script actually clone a repo
What I learned: os module allows you to perform various operations related to operating system
os.system() runs terminal commands from Python
os.path module is able to interact with file and directory paths throughout different operating systems
os.makedirs() allows you to create directories recursively, meaning can create intermediate directories that don't exist along with final target directory
Problems: - Learned that huge repos (2GB+) can cause issues
- Windows has filename length limits
- Removed first test project and switched to smaller test project (leerob/leerob.io)

Pomodoro 3 - installed dependencies.
What I did:
- Added npm install to my deploy.py script
- First attempt failed due to dependency conflicts in the repo
- Added --legacy-peer-deps flag to handle conflicts
- Successfully cloned and installed dependencies for a real Next.js project (1088 packages!)

What I learned:
- os.chdir() changes the working directory so commands run in the right folder
- Not all repos on GitHub have working dependencies (even popular ones)
- Real deployment platforms need to handle dependency conflicts
- --legacy-peer-deps is a way to bypass peer dependency issues
- npm install can take 2+ minutes for large projects
- Warnings about deprecated packages are normal and don't break builds

What worked:
- My script correctly cloned a 14MB repo
- Dependencies installed successfully with the workaround
- Script is now ready for final step: building

Problems I hit:
- Initial repo (Vercel Next.js) was too massive (2GB)
- Second repo (shadcn taxonomy) had dependency conflicts
- Fixed with --legacy-peer-deps flag

Pomodoro 4 - run npm build.
What I did:
- Added npm run build to complete the automation
- Script successfully: cloned repo, installed 1088 packages, ran build
- Build failed due to repo-specific issues (Contentlayer + Windows)
- Learned that not every repo builds successfully even with correct automation

What I learned:
- My script works correctly - it automated the entire deployment pipeline
- Some repos have platform-specific issues (Windows vs Mac/Linux)
- Real deployment platforms encounter these same issues
- Error handling is important - my script detected and reported the failure
- The automation is complete even if individual repos fail

Key insight:
The goal wasn't to build EVERY repo successfully. The goal was to automate the PROCESS. I did that. Vercel would also fail on this repo without proper config.

What worked:
✅ Clone automation
✅ Dependency installation automation  
✅ Build command execution
✅ Error detection and reporting

=== DAY 2 ACHIEVEMENT ===
I have a fully automated deployment script that:
- Takes any GitHub URL
- Clones it
- Installs dependencies
- Builds it
- Reports results

I just deployed a Next.js app (test-deployment) using automation I wrote.
My Python script:
- Installed dependencies
- Built the production files
- Started the server
All with one command python deploy.py

=== DAY 3 START ===

Pomodoro 1 - Just Get Flask Running 
What I just did:
- Imported Flask (a library for making web servers in Python)
- Created an "app" object
- Made a "route" - when someone visits /, show this text
- Started the server on port 5000

What I understand:
- @app.route('/') means "when someone visits the home page"
- The function below it decides what to show
- app.run() starts the web server
- It's like a Python program that responds to browser requests

What I don't understand yet:
- Flask syntax (__name__)
- what __main__ is

Pomodoro 2 - added a simple HTML page.
What I just did:
- Created an HTML file in templates folder
- Changed from returning text to returning an HTML page
- render_template() tells Flask to load the HTML file

What I understand:
- Flask looks for HTML files in the 'templates' folder
- render_template('index.html') loads that file
- The browser now shows HTML instead of plain text
- This is how Flask serves web pages

What I still don't understand:

Pomodoro 3 - added a form.
What I just did:
- Adden an input box (where users type)
- Added a button
- Gave the input an "id" so I can reference it later

What I understand:
- <input> creates a text box
- id="github_url" is like naming it so I can find it later
- The button doesn't do anything yet
- This is just the visual part (HTML)

What I need to learn next:
- How to make the button actually DO something
- How to get the text from the input box

Pomodoro 4 - Make the Button Show What You Typed
What I just did:
- Made the button call a function when clicked
- The function gets the text from the input box
- Then displays it in the <p> target

What I understand:
- onclick="showURL()" means "when clicked, run this function"
- document.getElementById() finds an element by its id
- .value gets what's in the input box
- .innerHTML changes what's shown in the paragraph

What I learned by breaking it:
- when you change the id, the button stops working because the JavaScript was targeting the old ID and can't find the old ID

=== DAY 4 START ===

Pomodoro 1 - Add a Deploy Endpoint.
What does methods=['POST'] mean?:
- It specifies that a web route should only respond to HTTP POST requests 
- POST requests are used to send data to a server, such as from an HTML form, to create or update a resource.
What's the difference between /deploy route and the /route?:
- /deploy is a custom route defined for a specific purpose (in this case, related to the app's deployment and infrastructure management)
- / is the root route and represents the home page or default entry point of a website or app
What does request.get_json() do?:
- In Flask, it's a method used to parse incoming JSON request data and return it as a Python object (usually dictionary or list)
- JSON (JavaScript Object Notation) request data refers to the data sent from a client to a server within the body of an HTTP request
What does jsonify() do?:
- The jsonify() function in Flask is used to convert Python data structures into a JSON-formatted response object. 
- Serializes Data to JSON: It takes provided Python data and converts it into JSON string
- Creates a Response Object: It then wraps this JSON string within a Flask Response object
- jsonify() automatically sets Content-Type header of the response to application/json, 
  which informs client that the received dat is in JSON format, allowing it to be parsed correctly

What does `fetch('/deploy', ...)` do?:
- It initiates an HTTP request to the /deploy endpoint of the current webser or application.
- Initiates a Network Request: The fetch() function is called, and the first argument, '/deploy', specifies
  the URL (or path) of the resource to be fetched. In this case, it's a relative path to an endpoint named
  deploy on the same origin as the client-side JavaScript
- Returns a Promise: The fetch() function immediately returns a Promise. This promise will eventually resolve
  to a Response object once the server responds, or it will reject if a network error occurs.
What does `method: 'POST'` mean?:
- In WebDev, method: 'POST' specifies that an HTTP request should use the POST method, which is designed to
  send data to a server to create a new resource or update the server's Started
What does `JSON.stringify()` do?:
- The JSON.stringify() method in JavaScript converts a JavaScript value (usually an object or array) into
  a JSON-formatted string. This is essential for sending data to a web server or stroing data, as data exchange
  often requires a string format that is universally understood.
What does `.then()` do?:
- In JavaScript, then .then() method is used with Promises to handle the reesults of an asynchronous operation.
- It accepts two callback functions: one for when the promise is successfully resolved and another for when it
  is rejected. The .then() method always returns a new Promise, which allows you to chain multiple asynchronous
  operations together in a readable way.
  What's the flow: Button click → ??? → Server → ??? → Page updates
  - Button click: a user interacts with a button on web page, triggering a client-side event handler
  - Client-side logic/API call: The event handler executes code that typically prepares data and initiates an
    asynchronous request (like using the fetch() API) to the server.
  - Server processing: The server receives the request, processes the data (e.g., interacts with a database,
    performs calculations), and prepares a response.
  - Data return/Server response: The server sends a response back to the client, usually in a structured format
    like JSON.
  - Client-side handling of response: Client-side JavaScript receives the response, parses the data, and
    manipulates the Document Object Model (DOM) of the web page to reflect the new information without requiring
    a full page reload.
  - Page updates: The user sees the changes on the page (e.g., new content appears, an element is hidden, a value
    is updated).

Break it on purpose:
- Change /deploy to /deploy2 in ONE place, you get SyntaxError: Unexpected token '<', "
- Change github_url to url in ONE place, you get SyntaxError: Unexpected token '<', "

What I built:
- I added a deploy endpoint to learn how to make Flash receive data from my HTML form and respond back.

The request-response flow:
1. It is a fundamental communication pattern where a client, like a web browser, sends an HTTP request to a server, which process request and sends back a response.
2. The cycle involves the client creating a request with details like the URL and method, sending it over the internet, the server interpreting it, generating data,
   and then sending that data back to the client, which renders it for the user.









